## 加速K-means
### 摘要
1. 提出新的k-means聚类算法；
2. 新型kd-tree算法＋新颖的剪枝技术——在子线性数据点和中心数量；
3. kd-tree子节点何以存储足够的统计信息；
4. 当前聚类中心的几何分析大量减少了更新中心的计算；
5. 证明了准确性；
6. kd-tree也用于有效初始化k-means的开始中心

### 介绍
> 定义（聚类问题）给当一个数据集和一个常量k，聚类问题是将数据分成k个子集，使得每个每个子集在某些测量下表现良好。

聚类问题的k-means算法基于该种测量方式寻找局部最优——跟踪子集的质心。

> 定义（kd-tree）kd树是用于存储有限维空间中有限点集的数据结构。

我们展示kd-trees能够用于减少k-means中的近邻查询。（也就是节约成本）因为其节点可以代表很多数据点。可以证明，kd-trees的特定节点有如下声明：任何和该节点有联系的点有X（一些中心）作为其最近邻。该特点和一些存储在kd-nodes中的统计量，使得更新聚类质心的计算量大大减少。

### 定义和相关工作
最朴素的k-means算法，将数据集分成k个类。
用 C subscript i in parentheses表示第i次迭代后的中心值。当 C subscript i 和 C subscript i-1相同时算法终止。每次迭代过程中，进行
1. 对每个点 x，在 C subscript i 中寻找和 x 距离最近的中心。将 x 和该中心建立联系；
2. 通过为每个中心取与该中心相关的点的质心来计算 C subscript i+1 

我们的算法只涉及在一次迭代中修改代码，也因此只分析一次计算消耗。朴素的k-means方法对每个点执行一个“最近邻中心”查询。在这样的查询下M维空间中的k个中心的距离被计算出来。因此消耗是O(kMR)。
kd-tree数据结构是我们解决该问题的基本工具。我们使用一个特殊版本的kd-trees成为mrkd-trees，用于“多分辨率kd-trees”，其性质为：

- 他们是二进制树
- 每个节点包含一个超矩形h中的所有点的信息。超矩形在节点中被存储成两个M长度的边界向量h subscript max 和 h subscript min。在节点处还存储h内所有点的个数、质心和欧几里得范数之和。 节点的所有子节点都表示H中包含的超矩形。

